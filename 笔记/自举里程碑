1.加电
  计算机从0xFFFF0开始运行，这个地址并是内存地址，而是会被地址线路由到bios固件上；
  bios会对内存做一些操作（设置中断向量表和中断处理程序）来为中断做准备，然后利用int中断指令，与自己准备的中断处理程序加载第一个扇区的数据到0x7C00,然后将cs置为0x7C0;
  然后就开始已经被加载到0x7C00的bootset.s代码了

2.栈的设置
  当bootsec.s将自己复制到0x90000的位置并跳转到该位置后，会设置栈段寄存器ss与栈指针sp，分别为0x9000，与0xFF00,从这时候开始，我们就可以在接下来的代码中使用栈了（比如call指令会隐式地使用栈）；

3.加载setup.s与system模块
  bootsec.s会利用bios留在内存中的中断向量表和中断处理程序来加载setup.s到位置0x90200位置，紧挨着bootsec.s；
  然后继续调用int 13加载system模块到0x10000位置，比bootsec.s和setup.s地址低了很多；
  操作系统全部代码加载完成

4.setup.s为保护模式做部分准备，并打开保护模式
  利用bios的中断程序得到硬件信息，并放到0x90000处，覆盖了bootsec.s的代码；
  关中断（eflag寄存器），开始重构中断与寻址体系；
  将system代码全部移动至0x0地址，覆盖所有bios构造的中断向量表数据与中断处理程序代码
  setup.s代码数据段中有一个预先写好的gdt，setup的代码会加载它们的地址到gdtr，这个gdt只有三个表项，第一个为空，后两个分别是代码段和数据段，且基地址都为0，段限长为8mb；而ldt是张空表；
  加载0x000000000000到ldtr寄存器，实际上这个位置是head.s的代码的位置，未来页目录表会在这个位置（覆盖head.s代码），也就是说，设置ldtr实际上没有作用，也从来没有被使用；
  打开A20，正式开始使用刚才设置的gdt进行内存寻址，（思考，虽然开始使用gdt开始寻址，但是cs和ds都还没有设置，那么在设置cs之前，cpu是怎么取指令的）
  对8259A中断控制器进行重新编程,这个步骤是因为保护模式下x86会屏蔽一些中断号，所以将这些被屏蔽的中断号对应的中断线映射到其它中断号
  长跳转到0x0地址，也就是head.s的开始位置，这一步也同时设置了cs段寄存器，使的cs指向gdt的第一项

5.head.s为保护模式做后半部分准备
  设置ds，es，fs，gs指向gdt的第二项（基址0，数据段，8mb段限长）；
  设置栈段ss段寄存器指向gdt第二项，同时设置栈指针，具体位置指向了0x1e25c，基本在内核的最末端位置；
  设置新的idt，原来的idtr指向0x0并没有实际使用，这里设置真正的idt，重建中断体系；idt为head.s中的一个数据段，位置在页表与软盘缓冲区之后；
  这个idt中共256个表项，每个8字节；指向一个head.s中的函数地址 ，这个函数输出一个提示信息表明对应的中断函数并没有设置；
  设置新的gdt，废弃原来在位置x90000的gdt，新的gdt紧接在新的idt之后，包含256个表项，其中第0项为空，第1项与第2项和原来基本相同，只不过段长变为16mb；
  重新加载段选择符到段各各段寄存器，包括栈段寄存器，栈的实际位置并没有改变
  将前5页（20kb）初始化为页目录与页表，提供给内核使用，这一步覆盖了head.s自身的绝大部分代码，只剩下末尾的idt（2kb）与gdt（2kb）和1kb软盘缓冲区
  通过控制积存器打开分页，这时候内核通过段与页的控制使得内核的逻辑地址=线性地址=物理地址
